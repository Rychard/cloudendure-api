/* 
 * CloudEndure API documentation
 *
 * Â© 2019 CloudEndure All rights reserved  # General Request authentication in CloudEndure's API is done using session cookies. A session cookie is returned upon successful execution of the \"login\" method. This value must then be provided within the request headers of all subsequent API requests.  ## Errors Some errors are not specifically written in every method since they may always return. Those are: 1) 401 (Unauthorized) - for unauthenticated requests. 2) 405 (Method Not Allowed) - for using a method that is not supported (POST instead of GET). 3) 403 (Forbidden) - request is authenticated, but the user is not allowed to access. 4) 422 (Unprocessable Entity) - for invalid input.  ## Formats All strings with date-time format are according to RFC3339.  All strings with \"duration\" format are according to ISO8601. For example, a full day duration can be specified with \"PNNNND\". 
 *
 * OpenAPI spec version: 5
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = CloudEndure.Client.SwaggerDateConverter;

namespace CloudEndure.Model
{
    /// <summary>
    /// Controls the behaviour of the replication servers, as well as the network communication from the CloudEndure agent.
    /// </summary>
    [DataContract]
        public partial class MachineReplicationConfiguration :  IEquatable<MachineReplicationConfiguration>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineReplicationConfiguration" /> class.
        /// </summary>
        /// <param name="volumeEncryptionKey">AWS only. ARN to private key for Volume Encryption. Possible values can be fetched from the Region object. .</param>
        /// <param name="replicationTags">AWS only. Tags that will be applied to every cloud resource created in the CloudEndure Staging Area..</param>
        /// <param name="disablePublicIp">When private IP is used, do not allocate public IP for replication server.</param>
        /// <param name="subnetHostProject">GCP only. Host project of cross project network subnet..</param>
        /// <param name="replicationSoftwareDownloadSource">replicationSoftwareDownloadSource.</param>
        /// <param name="replicationServerType">replicationServerType.</param>
        /// <param name="useLowCostDisks">use low cost disks for replication whenever possible.</param>
        /// <param name="computeLocationId">computeLocationId.</param>
        /// <param name="subnetId">Subnet where replication servers will be created. Possible values can be fetched from the Region object..</param>
        /// <param name="logicalLocationId">vcenter &#x3D; vmFolder.</param>
        /// <param name="bandwidthThrottling">Mbps to use for Data Replication (zero means no throttling)..</param>
        /// <param name="useDedicatedServer">useDedicatedServer.</param>
        /// <param name="zone">Relevant for GCP and Azure ARM. The Zone to replicate into..</param>
        /// <param name="replicatorSecurityGroupIDs">AWS only. The security groups that will be applied to the replication servers. Possible values can be fetched from the Region object..</param>
        /// <param name="usePrivateIp">Should the CloudEndure agent access the replication server using its private IP address..</param>
        /// <param name="proxyUrl">The full URI for a proxy (schema, username, password, domain, port) if required for the CloudEndure agent..</param>
        /// <param name="volumeEncryptionAllowed">volumeEncryptionAllowed.</param>
        /// <param name="objectStorageLocation">bucket in aws .</param>
        /// <param name="archivingEnabled">archivingEnabled.</param>
        /// <param name="converterType">converterType.</param>
        /// <param name="storageLocationId">storageLocationId.</param>
        /// <param name="stagingDisks">Replicator disk properties..</param>
        public MachineReplicationConfiguration(string volumeEncryptionKey = default(string), List<ReplicationConfigurationReplicationTags> replicationTags = default(List<ReplicationConfigurationReplicationTags>), bool? disablePublicIp = default(bool?), string subnetHostProject = default(string), string replicationSoftwareDownloadSource = default(string), string replicationServerType = default(string), bool? useLowCostDisks = default(bool?), string computeLocationId = default(string), string subnetId = default(string), string logicalLocationId = default(string), int? bandwidthThrottling = default(int?), bool? useDedicatedServer = default(bool?), string zone = default(string), List<string> replicatorSecurityGroupIDs = default(List<string>), bool? usePrivateIp = default(bool?), string proxyUrl = default(string), bool? volumeEncryptionAllowed = default(bool?), string objectStorageLocation = default(string), bool? archivingEnabled = default(bool?), string converterType = default(string), string storageLocationId = default(string), List<DiskConfig> stagingDisks = default(List<DiskConfig>))
        {
            this.VolumeEncryptionKey = volumeEncryptionKey;
            this.ReplicationTags = replicationTags;
            this.DisablePublicIp = disablePublicIp;
            this.SubnetHostProject = subnetHostProject;
            this.ReplicationSoftwareDownloadSource = replicationSoftwareDownloadSource;
            this.ReplicationServerType = replicationServerType;
            this.UseLowCostDisks = useLowCostDisks;
            this.ComputeLocationId = computeLocationId;
            this.SubnetId = subnetId;
            this.LogicalLocationId = logicalLocationId;
            this.BandwidthThrottling = bandwidthThrottling;
            this.UseDedicatedServer = useDedicatedServer;
            this.Zone = zone;
            this.ReplicatorSecurityGroupIDs = replicatorSecurityGroupIDs;
            this.UsePrivateIp = usePrivateIp;
            this.ProxyUrl = proxyUrl;
            this.VolumeEncryptionAllowed = volumeEncryptionAllowed;
            this.ObjectStorageLocation = objectStorageLocation;
            this.ArchivingEnabled = archivingEnabled;
            this.ConverterType = converterType;
            this.StorageLocationId = storageLocationId;
            this.StagingDisks = stagingDisks;
        }
        
        /// <summary>
        /// AWS only. ARN to private key for Volume Encryption. Possible values can be fetched from the Region object. 
        /// </summary>
        /// <value>AWS only. ARN to private key for Volume Encryption. Possible values can be fetched from the Region object. </value>
        [DataMember(Name="volumeEncryptionKey", EmitDefaultValue=false)]
        public string VolumeEncryptionKey { get; set; }

        /// <summary>
        /// AWS only. Tags that will be applied to every cloud resource created in the CloudEndure Staging Area.
        /// </summary>
        /// <value>AWS only. Tags that will be applied to every cloud resource created in the CloudEndure Staging Area.</value>
        [DataMember(Name="replicationTags", EmitDefaultValue=false)]
        public List<ReplicationConfigurationReplicationTags> ReplicationTags { get; set; }

        /// <summary>
        /// When private IP is used, do not allocate public IP for replication server
        /// </summary>
        /// <value>When private IP is used, do not allocate public IP for replication server</value>
        [DataMember(Name="disablePublicIp", EmitDefaultValue=false)]
        public bool? DisablePublicIp { get; set; }

        /// <summary>
        /// GCP only. Host project of cross project network subnet.
        /// </summary>
        /// <value>GCP only. Host project of cross project network subnet.</value>
        [DataMember(Name="subnetHostProject", EmitDefaultValue=false)]
        public string SubnetHostProject { get; set; }

        /// <summary>
        /// Gets or Sets NoRescan
        /// </summary>
        [DataMember(Name="noRescan", EmitDefaultValue=false)]
        public bool? NoRescan { get; private set; }

        /// <summary>
        /// Gets or Sets ReplicationSoftwareDownloadSource
        /// </summary>
        [DataMember(Name="replicationSoftwareDownloadSource", EmitDefaultValue=false)]
        public string ReplicationSoftwareDownloadSource { get; set; }

        /// <summary>
        /// Gets or Sets ReplicationServerType
        /// </summary>
        [DataMember(Name="replicationServerType", EmitDefaultValue=false)]
        public string ReplicationServerType { get; set; }

        /// <summary>
        /// use low cost disks for replication whenever possible
        /// </summary>
        /// <value>use low cost disks for replication whenever possible</value>
        [DataMember(Name="useLowCostDisks", EmitDefaultValue=false)]
        public bool? UseLowCostDisks { get; set; }

        /// <summary>
        /// Gets or Sets ComputeLocationId
        /// </summary>
        [DataMember(Name="computeLocationId", EmitDefaultValue=false)]
        public string ComputeLocationId { get; set; }

        /// <summary>
        /// Subnet where replication servers will be created. Possible values can be fetched from the Region object.
        /// </summary>
        /// <value>Subnet where replication servers will be created. Possible values can be fetched from the Region object.</value>
        [DataMember(Name="subnetId", EmitDefaultValue=false)]
        public string SubnetId { get; set; }

        /// <summary>
        /// vcenter &#x3D; vmFolder
        /// </summary>
        /// <value>vcenter &#x3D; vmFolder</value>
        [DataMember(Name="logicalLocationId", EmitDefaultValue=false)]
        public string LogicalLocationId { get; set; }

        /// <summary>
        /// Mbps to use for Data Replication (zero means no throttling).
        /// </summary>
        /// <value>Mbps to use for Data Replication (zero means no throttling).</value>
        [DataMember(Name="bandwidthThrottling", EmitDefaultValue=false)]
        public int? BandwidthThrottling { get; set; }

        /// <summary>
        /// Gets or Sets UseDedicatedServer
        /// </summary>
        [DataMember(Name="useDedicatedServer", EmitDefaultValue=false)]
        public bool? UseDedicatedServer { get; set; }

        /// <summary>
        /// Relevant for GCP and Azure ARM. The Zone to replicate into.
        /// </summary>
        /// <value>Relevant for GCP and Azure ARM. The Zone to replicate into.</value>
        [DataMember(Name="zone", EmitDefaultValue=false)]
        public string Zone { get; set; }

        /// <summary>
        /// AWS only. The security groups that will be applied to the replication servers. Possible values can be fetched from the Region object.
        /// </summary>
        /// <value>AWS only. The security groups that will be applied to the replication servers. Possible values can be fetched from the Region object.</value>
        [DataMember(Name="replicatorSecurityGroupIDs", EmitDefaultValue=false)]
        public List<string> ReplicatorSecurityGroupIDs { get; set; }

        /// <summary>
        /// Should the CloudEndure agent access the replication server using its private IP address.
        /// </summary>
        /// <value>Should the CloudEndure agent access the replication server using its private IP address.</value>
        [DataMember(Name="usePrivateIp", EmitDefaultValue=false)]
        public bool? UsePrivateIp { get; set; }

        /// <summary>
        /// The full URI for a proxy (schema, username, password, domain, port) if required for the CloudEndure agent.
        /// </summary>
        /// <value>The full URI for a proxy (schema, username, password, domain, port) if required for the CloudEndure agent.</value>
        [DataMember(Name="proxyUrl", EmitDefaultValue=false)]
        public string ProxyUrl { get; set; }

        /// <summary>
        /// Gets or Sets VolumeEncryptionAllowed
        /// </summary>
        [DataMember(Name="volumeEncryptionAllowed", EmitDefaultValue=false)]
        public bool? VolumeEncryptionAllowed { get; set; }

        /// <summary>
        /// bucket in aws 
        /// </summary>
        /// <value>bucket in aws </value>
        [DataMember(Name="objectStorageLocation", EmitDefaultValue=false)]
        public string ObjectStorageLocation { get; set; }

        /// <summary>
        /// Gets or Sets ArchivingEnabled
        /// </summary>
        [DataMember(Name="archivingEnabled", EmitDefaultValue=false)]
        public bool? ArchivingEnabled { get; set; }

        /// <summary>
        /// Gets or Sets ConverterType
        /// </summary>
        [DataMember(Name="converterType", EmitDefaultValue=false)]
        public string ConverterType { get; set; }

        /// <summary>
        /// Gets or Sets StorageLocationId
        /// </summary>
        [DataMember(Name="storageLocationId", EmitDefaultValue=false)]
        public string StorageLocationId { get; set; }

        /// <summary>
        /// Replicator disk properties.
        /// </summary>
        /// <value>Replicator disk properties.</value>
        [DataMember(Name="stagingDisks", EmitDefaultValue=false)]
        public List<DiskConfig> StagingDisks { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MachineReplicationConfiguration {\n");
            sb.Append("  VolumeEncryptionKey: ").Append(VolumeEncryptionKey).Append("\n");
            sb.Append("  ReplicationTags: ").Append(ReplicationTags).Append("\n");
            sb.Append("  DisablePublicIp: ").Append(DisablePublicIp).Append("\n");
            sb.Append("  SubnetHostProject: ").Append(SubnetHostProject).Append("\n");
            sb.Append("  NoRescan: ").Append(NoRescan).Append("\n");
            sb.Append("  ReplicationSoftwareDownloadSource: ").Append(ReplicationSoftwareDownloadSource).Append("\n");
            sb.Append("  ReplicationServerType: ").Append(ReplicationServerType).Append("\n");
            sb.Append("  UseLowCostDisks: ").Append(UseLowCostDisks).Append("\n");
            sb.Append("  ComputeLocationId: ").Append(ComputeLocationId).Append("\n");
            sb.Append("  SubnetId: ").Append(SubnetId).Append("\n");
            sb.Append("  LogicalLocationId: ").Append(LogicalLocationId).Append("\n");
            sb.Append("  BandwidthThrottling: ").Append(BandwidthThrottling).Append("\n");
            sb.Append("  UseDedicatedServer: ").Append(UseDedicatedServer).Append("\n");
            sb.Append("  Zone: ").Append(Zone).Append("\n");
            sb.Append("  ReplicatorSecurityGroupIDs: ").Append(ReplicatorSecurityGroupIDs).Append("\n");
            sb.Append("  UsePrivateIp: ").Append(UsePrivateIp).Append("\n");
            sb.Append("  ProxyUrl: ").Append(ProxyUrl).Append("\n");
            sb.Append("  VolumeEncryptionAllowed: ").Append(VolumeEncryptionAllowed).Append("\n");
            sb.Append("  ObjectStorageLocation: ").Append(ObjectStorageLocation).Append("\n");
            sb.Append("  ArchivingEnabled: ").Append(ArchivingEnabled).Append("\n");
            sb.Append("  ConverterType: ").Append(ConverterType).Append("\n");
            sb.Append("  StorageLocationId: ").Append(StorageLocationId).Append("\n");
            sb.Append("  StagingDisks: ").Append(StagingDisks).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MachineReplicationConfiguration);
        }

        /// <summary>
        /// Returns true if MachineReplicationConfiguration instances are equal
        /// </summary>
        /// <param name="input">Instance of MachineReplicationConfiguration to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MachineReplicationConfiguration input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.VolumeEncryptionKey == input.VolumeEncryptionKey ||
                    (this.VolumeEncryptionKey != null &&
                    this.VolumeEncryptionKey.Equals(input.VolumeEncryptionKey))
                ) && 
                (
                    this.ReplicationTags == input.ReplicationTags ||
                    this.ReplicationTags != null &&
                    input.ReplicationTags != null &&
                    this.ReplicationTags.SequenceEqual(input.ReplicationTags)
                ) && 
                (
                    this.DisablePublicIp == input.DisablePublicIp ||
                    (this.DisablePublicIp != null &&
                    this.DisablePublicIp.Equals(input.DisablePublicIp))
                ) && 
                (
                    this.SubnetHostProject == input.SubnetHostProject ||
                    (this.SubnetHostProject != null &&
                    this.SubnetHostProject.Equals(input.SubnetHostProject))
                ) && 
                (
                    this.NoRescan == input.NoRescan ||
                    (this.NoRescan != null &&
                    this.NoRescan.Equals(input.NoRescan))
                ) && 
                (
                    this.ReplicationSoftwareDownloadSource == input.ReplicationSoftwareDownloadSource ||
                    (this.ReplicationSoftwareDownloadSource != null &&
                    this.ReplicationSoftwareDownloadSource.Equals(input.ReplicationSoftwareDownloadSource))
                ) && 
                (
                    this.ReplicationServerType == input.ReplicationServerType ||
                    (this.ReplicationServerType != null &&
                    this.ReplicationServerType.Equals(input.ReplicationServerType))
                ) && 
                (
                    this.UseLowCostDisks == input.UseLowCostDisks ||
                    (this.UseLowCostDisks != null &&
                    this.UseLowCostDisks.Equals(input.UseLowCostDisks))
                ) && 
                (
                    this.ComputeLocationId == input.ComputeLocationId ||
                    (this.ComputeLocationId != null &&
                    this.ComputeLocationId.Equals(input.ComputeLocationId))
                ) && 
                (
                    this.SubnetId == input.SubnetId ||
                    (this.SubnetId != null &&
                    this.SubnetId.Equals(input.SubnetId))
                ) && 
                (
                    this.LogicalLocationId == input.LogicalLocationId ||
                    (this.LogicalLocationId != null &&
                    this.LogicalLocationId.Equals(input.LogicalLocationId))
                ) && 
                (
                    this.BandwidthThrottling == input.BandwidthThrottling ||
                    (this.BandwidthThrottling != null &&
                    this.BandwidthThrottling.Equals(input.BandwidthThrottling))
                ) && 
                (
                    this.UseDedicatedServer == input.UseDedicatedServer ||
                    (this.UseDedicatedServer != null &&
                    this.UseDedicatedServer.Equals(input.UseDedicatedServer))
                ) && 
                (
                    this.Zone == input.Zone ||
                    (this.Zone != null &&
                    this.Zone.Equals(input.Zone))
                ) && 
                (
                    this.ReplicatorSecurityGroupIDs == input.ReplicatorSecurityGroupIDs ||
                    this.ReplicatorSecurityGroupIDs != null &&
                    input.ReplicatorSecurityGroupIDs != null &&
                    this.ReplicatorSecurityGroupIDs.SequenceEqual(input.ReplicatorSecurityGroupIDs)
                ) && 
                (
                    this.UsePrivateIp == input.UsePrivateIp ||
                    (this.UsePrivateIp != null &&
                    this.UsePrivateIp.Equals(input.UsePrivateIp))
                ) && 
                (
                    this.ProxyUrl == input.ProxyUrl ||
                    (this.ProxyUrl != null &&
                    this.ProxyUrl.Equals(input.ProxyUrl))
                ) && 
                (
                    this.VolumeEncryptionAllowed == input.VolumeEncryptionAllowed ||
                    (this.VolumeEncryptionAllowed != null &&
                    this.VolumeEncryptionAllowed.Equals(input.VolumeEncryptionAllowed))
                ) && 
                (
                    this.ObjectStorageLocation == input.ObjectStorageLocation ||
                    (this.ObjectStorageLocation != null &&
                    this.ObjectStorageLocation.Equals(input.ObjectStorageLocation))
                ) && 
                (
                    this.ArchivingEnabled == input.ArchivingEnabled ||
                    (this.ArchivingEnabled != null &&
                    this.ArchivingEnabled.Equals(input.ArchivingEnabled))
                ) && 
                (
                    this.ConverterType == input.ConverterType ||
                    (this.ConverterType != null &&
                    this.ConverterType.Equals(input.ConverterType))
                ) && 
                (
                    this.StorageLocationId == input.StorageLocationId ||
                    (this.StorageLocationId != null &&
                    this.StorageLocationId.Equals(input.StorageLocationId))
                ) && 
                (
                    this.StagingDisks == input.StagingDisks ||
                    this.StagingDisks != null &&
                    input.StagingDisks != null &&
                    this.StagingDisks.SequenceEqual(input.StagingDisks)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.VolumeEncryptionKey != null)
                    hashCode = hashCode * 59 + this.VolumeEncryptionKey.GetHashCode();
                if (this.ReplicationTags != null)
                    hashCode = hashCode * 59 + this.ReplicationTags.GetHashCode();
                if (this.DisablePublicIp != null)
                    hashCode = hashCode * 59 + this.DisablePublicIp.GetHashCode();
                if (this.SubnetHostProject != null)
                    hashCode = hashCode * 59 + this.SubnetHostProject.GetHashCode();
                if (this.NoRescan != null)
                    hashCode = hashCode * 59 + this.NoRescan.GetHashCode();
                if (this.ReplicationSoftwareDownloadSource != null)
                    hashCode = hashCode * 59 + this.ReplicationSoftwareDownloadSource.GetHashCode();
                if (this.ReplicationServerType != null)
                    hashCode = hashCode * 59 + this.ReplicationServerType.GetHashCode();
                if (this.UseLowCostDisks != null)
                    hashCode = hashCode * 59 + this.UseLowCostDisks.GetHashCode();
                if (this.ComputeLocationId != null)
                    hashCode = hashCode * 59 + this.ComputeLocationId.GetHashCode();
                if (this.SubnetId != null)
                    hashCode = hashCode * 59 + this.SubnetId.GetHashCode();
                if (this.LogicalLocationId != null)
                    hashCode = hashCode * 59 + this.LogicalLocationId.GetHashCode();
                if (this.BandwidthThrottling != null)
                    hashCode = hashCode * 59 + this.BandwidthThrottling.GetHashCode();
                if (this.UseDedicatedServer != null)
                    hashCode = hashCode * 59 + this.UseDedicatedServer.GetHashCode();
                if (this.Zone != null)
                    hashCode = hashCode * 59 + this.Zone.GetHashCode();
                if (this.ReplicatorSecurityGroupIDs != null)
                    hashCode = hashCode * 59 + this.ReplicatorSecurityGroupIDs.GetHashCode();
                if (this.UsePrivateIp != null)
                    hashCode = hashCode * 59 + this.UsePrivateIp.GetHashCode();
                if (this.ProxyUrl != null)
                    hashCode = hashCode * 59 + this.ProxyUrl.GetHashCode();
                if (this.VolumeEncryptionAllowed != null)
                    hashCode = hashCode * 59 + this.VolumeEncryptionAllowed.GetHashCode();
                if (this.ObjectStorageLocation != null)
                    hashCode = hashCode * 59 + this.ObjectStorageLocation.GetHashCode();
                if (this.ArchivingEnabled != null)
                    hashCode = hashCode * 59 + this.ArchivingEnabled.GetHashCode();
                if (this.ConverterType != null)
                    hashCode = hashCode * 59 + this.ConverterType.GetHashCode();
                if (this.StorageLocationId != null)
                    hashCode = hashCode * 59 + this.StorageLocationId.GetHashCode();
                if (this.StagingDisks != null)
                    hashCode = hashCode * 59 + this.StagingDisks.GetHashCode();
                return hashCode;
            }
        }
    }
}
