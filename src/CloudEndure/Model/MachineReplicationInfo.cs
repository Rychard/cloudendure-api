/* 
 * CloudEndure API documentation
 *
 * Â© 2019 CloudEndure All rights reserved  # General Request authentication in CloudEndure's API is done using session cookies. A session cookie is returned upon successful execution of the \"login\" method. This value must then be provided within the request headers of all subsequent API requests.  ## Errors Some errors are not specifically written in every method since they may always return. Those are: 1) 401 (Unauthorized) - for unauthenticated requests. 2) 405 (Method Not Allowed) - for using a method that is not supported (POST instead of GET). 3) 403 (Forbidden) - request is authenticated, but the user is not allowed to access. 4) 422 (Unprocessable Entity) - for invalid input.  ## Formats All strings with date-time format are according to RFC3339.  All strings with \"duration\" format are according to ISO8601. For example, a full day duration can be specified with \"PNNNND\". 
 *
 * OpenAPI spec version: 5
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = CloudEndure.Client.SwaggerDateConverter;

namespace CloudEndure.Model
{
    /// <summary>
    /// Detailed information on the state of replication.
    /// </summary>
    [DataContract]
        public partial class MachineReplicationInfo :  IEquatable<MachineReplicationInfo>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineReplicationInfo" /> class.
        /// </summary>
        /// <param name="rescannedStorageBytes">Amount of data rescanned (in Bytes)..</param>
        /// <param name="backloggedStorageBytes">Amount of data requiring sync (in Bytes), that has not yet been sent..</param>
        /// <param name="lastConsistencyDateTime">Timestamp of last disk replication consistency event..</param>
        /// <param name="nextConsistencyEstimatedDateTime">Timestamp of estimate for the next disk replication consistency event..</param>
        /// <param name="totalStorageBytes">Total storage being replicated (in Bytes)..</param>
        /// <param name="initiationStates">initiationStates.</param>
        /// <param name="replicatedStorageBytes">Amount of data already synced (in Bytes)..</param>
        /// <param name="lastSeenDateTime">lastSeenDateTime.</param>
        /// <param name="lastScanStartDateTime">Timestamp of last time a volume scan has started..</param>
        public MachineReplicationInfo(long? rescannedStorageBytes = default(long?), long? backloggedStorageBytes = default(long?), DateTime? lastConsistencyDateTime = default(DateTime?), DateTime? nextConsistencyEstimatedDateTime = default(DateTime?), long? totalStorageBytes = default(long?), MachineReplicationInfoInitiationStates initiationStates = default(MachineReplicationInfoInitiationStates), long? replicatedStorageBytes = default(long?), DateTime? lastSeenDateTime = default(DateTime?), DateTime? lastScanStartDateTime = default(DateTime?))
        {
            this.RescannedStorageBytes = rescannedStorageBytes;
            this.BackloggedStorageBytes = backloggedStorageBytes;
            this.LastConsistencyDateTime = lastConsistencyDateTime;
            this.NextConsistencyEstimatedDateTime = nextConsistencyEstimatedDateTime;
            this.TotalStorageBytes = totalStorageBytes;
            this.InitiationStates = initiationStates;
            this.ReplicatedStorageBytes = replicatedStorageBytes;
            this.LastSeenDateTime = lastSeenDateTime;
            this.LastScanStartDateTime = lastScanStartDateTime;
        }
        
        /// <summary>
        /// Amount of data rescanned (in Bytes).
        /// </summary>
        /// <value>Amount of data rescanned (in Bytes).</value>
        [DataMember(Name="rescannedStorageBytes", EmitDefaultValue=false)]
        public long? RescannedStorageBytes { get; set; }

        /// <summary>
        /// Amount of data requiring sync (in Bytes), that has not yet been sent.
        /// </summary>
        /// <value>Amount of data requiring sync (in Bytes), that has not yet been sent.</value>
        [DataMember(Name="backloggedStorageBytes", EmitDefaultValue=false)]
        public long? BackloggedStorageBytes { get; set; }

        /// <summary>
        /// Timestamp of last disk replication consistency event.
        /// </summary>
        /// <value>Timestamp of last disk replication consistency event.</value>
        [DataMember(Name="lastConsistencyDateTime", EmitDefaultValue=false)]
        public DateTime? LastConsistencyDateTime { get; set; }

        /// <summary>
        /// Timestamp of estimate for the next disk replication consistency event.
        /// </summary>
        /// <value>Timestamp of estimate for the next disk replication consistency event.</value>
        [DataMember(Name="nextConsistencyEstimatedDateTime", EmitDefaultValue=false)]
        public DateTime? NextConsistencyEstimatedDateTime { get; set; }

        /// <summary>
        /// Total storage being replicated (in Bytes).
        /// </summary>
        /// <value>Total storage being replicated (in Bytes).</value>
        [DataMember(Name="totalStorageBytes", EmitDefaultValue=false)]
        public long? TotalStorageBytes { get; set; }

        /// <summary>
        /// Gets or Sets InitiationStates
        /// </summary>
        [DataMember(Name="initiationStates", EmitDefaultValue=false)]
        public MachineReplicationInfoInitiationStates InitiationStates { get; set; }

        /// <summary>
        /// Amount of data already synced (in Bytes).
        /// </summary>
        /// <value>Amount of data already synced (in Bytes).</value>
        [DataMember(Name="replicatedStorageBytes", EmitDefaultValue=false)]
        public long? ReplicatedStorageBytes { get; set; }

        /// <summary>
        /// Gets or Sets LastSeenDateTime
        /// </summary>
        [DataMember(Name="lastSeenDateTime", EmitDefaultValue=false)]
        public DateTime? LastSeenDateTime { get; set; }

        /// <summary>
        /// Timestamp of last time a volume scan has started.
        /// </summary>
        /// <value>Timestamp of last time a volume scan has started.</value>
        [DataMember(Name="lastScanStartDateTime", EmitDefaultValue=false)]
        public DateTime? LastScanStartDateTime { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MachineReplicationInfo {\n");
            sb.Append("  RescannedStorageBytes: ").Append(RescannedStorageBytes).Append("\n");
            sb.Append("  BackloggedStorageBytes: ").Append(BackloggedStorageBytes).Append("\n");
            sb.Append("  LastConsistencyDateTime: ").Append(LastConsistencyDateTime).Append("\n");
            sb.Append("  NextConsistencyEstimatedDateTime: ").Append(NextConsistencyEstimatedDateTime).Append("\n");
            sb.Append("  TotalStorageBytes: ").Append(TotalStorageBytes).Append("\n");
            sb.Append("  InitiationStates: ").Append(InitiationStates).Append("\n");
            sb.Append("  ReplicatedStorageBytes: ").Append(ReplicatedStorageBytes).Append("\n");
            sb.Append("  LastSeenDateTime: ").Append(LastSeenDateTime).Append("\n");
            sb.Append("  LastScanStartDateTime: ").Append(LastScanStartDateTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MachineReplicationInfo);
        }

        /// <summary>
        /// Returns true if MachineReplicationInfo instances are equal
        /// </summary>
        /// <param name="input">Instance of MachineReplicationInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MachineReplicationInfo input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.RescannedStorageBytes == input.RescannedStorageBytes ||
                    (this.RescannedStorageBytes != null &&
                    this.RescannedStorageBytes.Equals(input.RescannedStorageBytes))
                ) && 
                (
                    this.BackloggedStorageBytes == input.BackloggedStorageBytes ||
                    (this.BackloggedStorageBytes != null &&
                    this.BackloggedStorageBytes.Equals(input.BackloggedStorageBytes))
                ) && 
                (
                    this.LastConsistencyDateTime == input.LastConsistencyDateTime ||
                    (this.LastConsistencyDateTime != null &&
                    this.LastConsistencyDateTime.Equals(input.LastConsistencyDateTime))
                ) && 
                (
                    this.NextConsistencyEstimatedDateTime == input.NextConsistencyEstimatedDateTime ||
                    (this.NextConsistencyEstimatedDateTime != null &&
                    this.NextConsistencyEstimatedDateTime.Equals(input.NextConsistencyEstimatedDateTime))
                ) && 
                (
                    this.TotalStorageBytes == input.TotalStorageBytes ||
                    (this.TotalStorageBytes != null &&
                    this.TotalStorageBytes.Equals(input.TotalStorageBytes))
                ) && 
                (
                    this.InitiationStates == input.InitiationStates ||
                    (this.InitiationStates != null &&
                    this.InitiationStates.Equals(input.InitiationStates))
                ) && 
                (
                    this.ReplicatedStorageBytes == input.ReplicatedStorageBytes ||
                    (this.ReplicatedStorageBytes != null &&
                    this.ReplicatedStorageBytes.Equals(input.ReplicatedStorageBytes))
                ) && 
                (
                    this.LastSeenDateTime == input.LastSeenDateTime ||
                    (this.LastSeenDateTime != null &&
                    this.LastSeenDateTime.Equals(input.LastSeenDateTime))
                ) && 
                (
                    this.LastScanStartDateTime == input.LastScanStartDateTime ||
                    (this.LastScanStartDateTime != null &&
                    this.LastScanStartDateTime.Equals(input.LastScanStartDateTime))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RescannedStorageBytes != null)
                    hashCode = hashCode * 59 + this.RescannedStorageBytes.GetHashCode();
                if (this.BackloggedStorageBytes != null)
                    hashCode = hashCode * 59 + this.BackloggedStorageBytes.GetHashCode();
                if (this.LastConsistencyDateTime != null)
                    hashCode = hashCode * 59 + this.LastConsistencyDateTime.GetHashCode();
                if (this.NextConsistencyEstimatedDateTime != null)
                    hashCode = hashCode * 59 + this.NextConsistencyEstimatedDateTime.GetHashCode();
                if (this.TotalStorageBytes != null)
                    hashCode = hashCode * 59 + this.TotalStorageBytes.GetHashCode();
                if (this.InitiationStates != null)
                    hashCode = hashCode * 59 + this.InitiationStates.GetHashCode();
                if (this.ReplicatedStorageBytes != null)
                    hashCode = hashCode * 59 + this.ReplicatedStorageBytes.GetHashCode();
                if (this.LastSeenDateTime != null)
                    hashCode = hashCode * 59 + this.LastSeenDateTime.GetHashCode();
                if (this.LastScanStartDateTime != null)
                    hashCode = hashCode * 59 + this.LastScanStartDateTime.GetHashCode();
                return hashCode;
            }
        }
    }
}
